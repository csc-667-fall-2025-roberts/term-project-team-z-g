<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Game #<%= game.id %> ‚Äì Hidden Joker Rummy</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="/css/main.css" />
    <style>
      .playing-card {
        width: 80px;
        height: 112px;
        border: 2px solid #333;
        border-radius: 8px;
        padding: 8px;
        margin: 4px;
        display: inline-block;
        background: white;
        cursor: grab;
        transition: transform 0.2s, box-shadow 0.2s;
        user-select: none;
      }
      .playing-card:active {
        cursor: grabbing;
      }
      .playing-card:hover {
        transform: translateY(-10px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      }
      .playing-card.selected {
        transform: translateY(-15px);
        box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        border-color: #ffc107;
      }
      .playing-card.dragging {
        opacity: 0.5;
      }
      .playing-card.red { color: #dc3545; }
      .playing-card.black { color: #212529; }
      .card-rank { font-size: 1.2rem; font-weight: bold; }
      .card-suit { font-size: 1.5rem; }
      .card-back {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .game-center {
        display: flex;
        gap: 20px;
        justify-content: center;
        margin: 30px 0;
      }
      .deck-area {
        width: 100px;
        height: 140px;
        border: 3px dashed #6c757d;
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s;
      }
      .deck-area:hover {
        border-color: #0d6efd;
        background: rgba(13, 110, 253, 0.1);
      }
      .player-hand {
        min-height: 140px;
        padding: 20px;
        background: #f8f9fa;
        border-radius: 10px;
      }
      .other-players {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        margin-bottom: 20px;
      }
      .player-info {
        padding: 10px 20px;
        background: white;
        border-radius: 8px;
        border: 2px solid #dee2e6;
      }
      .player-info.active {
        border-color: #198754;
        background: #d1e7dd;
      }
      .results-image {
        max-width: 100%;
        height: auto;
        border-radius: 8px;
        border: 2px solid #dee2e6;
      }
      /* Results modal styling */
      .modal-backdrop.show { opacity: 0.5; }
      .results-card {
        background: #fdfbf6;
        border: 2px solid #2b3a67;
        border-radius: 16px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.25);
      }
      .results-title { color: #2b3a67; font-weight: 700; }
      .results-winner { color: #5c3ba0; font-weight: 700; font-size: 1.35rem; }
      .results-joker { background: #e0f7f1; border: 2px solid #1aa68a; border-radius: 10px; padding: 10px 14px; display: inline-block; font-weight: 600; }
      .results-list { border: 2px solid #d33; border-radius: 10px; padding: 10px 14px; background: #fff; }
      .results-list + .results-list { margin-top: 10px; }
      .results-buttons .btn { min-width: 140px; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <script>
      // Fallback: if CDN fails, load from node_modules
      if (!window.bootstrap) {
        const script = document.createElement('script');
        script.src = '/node_modules/bootstrap/dist/js/bootstrap.bundle.min.js';
        document.head.appendChild(script);
      }
    </script>
    <script src="/js/bundle.js"></script>
  </head>
  <body>
    <nav class="navbar navbar-dark bg-dark shadow-sm">
      <div class="container d-flex justify-content-between align-items-center">
        <a class="navbar-brand" href="/lobby">Hidden Joker Rummy</a>
        <div class="d-flex align-items-center gap-3">
          <span class="text-light small">Hi, <strong><%= currentUser?.username %></strong></span>
          <a href="/lobby" class="btn btn-outline-light btn-sm">Back to Lobby</a>
          <a href="/auth/logout" class="btn btn-outline-light btn-sm">Logout</a>
        </div>
      </div>
    </nav>

    <main class="main-container">
      <div class="container-fluid">
        <div class="row">
          <!-- Left Column: Game Board -->
          <div class="col-lg-9">
            <div class="card mb-3 shadow">
              <div class="card-body d-flex justify-content-between align-items-center">
                <div>
                  <h1 class="h5 mb-1"><%= game.name %></h1>
                  <div class="small text-muted">
                    Game ID: <%= game.id %> ¬∑ State: <span id="game-state"><%= game.state %></span>
                    <% 
                      // Find current player's joker_revealed status
                      const currentUserId = ((typeof session !== 'undefined') && session.user) ? session.user.id : null;
                      const currentPlayer = gameState?.players?.find(p => p.player_id === currentUserId);
                      const canSeeJoker = currentPlayer?.joker_revealed;
                      const headerJoker = (game && game.hidden_joker_rank) || (gameState && gameState.hidden_joker_rank);
                      
                      if (headerJoker && canSeeJoker) { 
                    %>
                      ¬∑ Joker: <strong class="text-warning"><%= headerJoker %></strong>
                    <% } else if (game.state === 'waiting') { %>
                      ¬∑ Joker: <span class="text-muted">(set when game starts)</span>
                    <% } else if (game.state === 'in_progress') { %>
                      ¬∑ Joker: <span class="text-muted" id="joker-hidden">‚ùì (lay pure sequence to reveal)</span>
                    <% } %>
                  </div>
                </div>
                <div class="d-flex gap-2">
                  <% if (game.state === 'waiting') { %>
                    <button id="start-game" class="btn btn-success">Start Game</button>
                  <% } %>
                  <button id="declare-btn" class="btn btn-outline-warning" style="display: none;">End Game</button>
                </div>
              </div>
            </div>

        <div class="other-players" id="other-players"></div>

        <div class="game-center">
          <div class="deck-area" id="draw-deck-btn">
            <div class="text-center">
              <div class="card-back playing-card">üé¥</div>
              <div class="small mt-2">Draw Deck</div>
              <div class="small text-muted" id="deck-count">52</div>
            </div>
          </div>
          <div class="deck-area" id="draw-discard-btn">
            <div class="text-center">
              <div id="discard-top-card">
                <div class="text-muted">Discard Pile</div>
                <div class="small text-muted">Empty</div>
              </div>
            </div>
          </div>
        </div>

        <div class="player-hand">
          <h5 class="text-dark">Your Hand</h5>
          <div id="player-hand" class="d-flex flex-wrap"></div>
          <div class="mt-3">
            <button id="lay-down-set-btn" class="btn btn-success me-2">Lay Down Sequence</button>
            <button id="discard-btn" class="btn btn-primary" disabled>Discard Selected Card</button>
            <span class="small text-muted ms-3" id="turn-indicator"></span>
          </div>
          <div id="meld-message" class="mt-2 small"></div>
        </div>

        <div class="card mt-3">
          <div class="card-body">
            <h5 class="h6 mb-2">Your Laid Sets</h5>
            <div id="laid-sets" class="d-flex flex-wrap gap-2 mb-3"></div>
            <div class="d-flex align-items-center gap-2">
              <label for="meld-select" class="small text-muted">Select a set:</label>
              <select id="meld-select" class="form-select form-select-sm" style="max-width: 220px;"></select>
              <button id="add-to-meld-btn" class="btn btn-outline-success btn-sm" disabled>Add selected card to set</button>
              <span id="add-to-meld-msg" class="small ms-2"></span>
            </div>
          </div>
        </div>

        <div id="error-alert" class="alert alert-danger mt-3" style="display: none;"></div>
        <div id="finished-banner" class="alert alert-success mt-3" style="display: none;">
          <div class="d-flex flex-column gap-2">
            <span id="finished-text">Game over!</span>
            <img id="results-img" class="results-image" src="/images/IMG_1340.jpeg" alt="Game results" onerror="this.style.display='none'" />
            <div>
              <button id="finished-back-btn" class="btn btn-outline-light btn-sm">View Results Page</button>
            </div>
          </div>
        </div>

        <!-- Results Modal -->
        <div class="modal fade" id="results-modal" tabindex="-1" aria-hidden="true">
          <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content results-card p-3">
              <div class="modal-header border-0 pb-0">
                <h5 class="modal-title results-title">Game Results</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
              </div>
              <div class="modal-body">
                <div class="results-winner" id="results-winner-text">Player Wins!</div>
                <div class="results-joker mt-2" id="results-joker-text" style="display:none;">Hidden Joker Revealed: <span class="results-rank" id="results-joker-rank"></span></div>
                <div class="mt-3" id="results-scores"></div>
              </div>
              <div class="modal-footer border-0 results-buttons d-flex justify-content-between w-100">
                <button type="button" class="btn btn-outline-primary" id="results-play-again">Play Again</button>
                <button type="button" class="btn btn-primary" id="results-to-lobby">Return to Lobby</button>
              </div>
            </div>
          </div>
        </div>
      </div>
      <!-- End Left Column -->

      <!-- Right Column: Game Chat -->
      <div class="col-lg-3">
        <div class="card shadow" style="height: calc(100vh - 100px); display: flex; flex-direction: column;">
          <div class="card-body d-flex flex-column" style="flex: 1; padding: 1rem;">
            <h5 class="card-title text-danger mb-3">Game Chat</h5>
            <div id="game-message-listing" class="mb-3 p-3 bg-light rounded flex-grow-1" style="overflow-y: auto; border: 1px solid #dee2e6; min-height: 0;">
              <!-- Messages will be appended here -->
            </div>
            <form id="game-chat-form" class="d-flex gap-2 mt-auto">
              <input 
                type="text" 
                id="game-chat-input" 
                class="form-control" 
                placeholder="Type a message..." 
                autocomplete="off"
                maxlength="500"
              />
              <button type="submit" class="btn btn-info text-white">Send</button>
            </form>
          </div>
        </div>
      </div>
      <!-- End Right Column -->
    </div>
    <!-- End Row -->

        <!-- Game Message Template -->
        <template id="game-message-template">
          <div class="chat-message mb-2">
            <div class="d-flex justify-content-between">
              <span class="message-username fw-bold text-warning"></span>
              <span class="message-time text-muted small"></span>
            </div>
            <div class="text-dark">
              <span class="message-text"></span>
            </div>
          </div>
        </template>
      </div>
    </main>

    <script>
      const gameId = <%= game.id %>;
      const currentUserId = <%= currentUser?.id ? currentUser.id : 'null' %>;
      let selectedCardId = null;
      let selectedCardsForSet = []; // Track multiple cards for set laying
      let gameState = null;
      let playerCards = [];
      let cardOrder = []; // Track custom card order by card ID
      let resultsModal = null;
      let dragPayload = null; // Tracks cross-area drag info
      function updateAddToMeldButton() {
        const addBtn = document.getElementById('add-to-meld-btn');
        const select = document.getElementById('meld-select');
        if (!addBtn || !select || !gameState) return;
        const me = gameState.players?.find(p => p.player_id === currentUserId);
        const melds = Array.isArray(me?.melds) ? me.melds : (me?.melds ? JSON.parse(me.melds) : []);
        const hasMelds = Array.isArray(melds) && melds.length > 0;
        const hasCard = selectedCardId !== null;
        addBtn.disabled = !(hasMelds && hasCard);
      }

      async function moveCardBetweenGroups(params) {
        try {
          const res = await fetch(`/games/${gameId}/move-card-between-groups`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(params)
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok) {
            showMeldMessage(data.error || 'Move failed', 'error');
            return;
          }
          await loadGameState();
          // Show special message if meld was dissolved
          if (data.message) {
            showMeldMessage(data.message, 'success');
          } else {
            showMeldMessage('Card moved', 'success');
          }
        } catch (err) {
          console.error('moveCardBetweenGroups error', err);
          showMeldMessage('Error: ' + err.message, 'error');
        } finally {
          dragPayload = null;
        }
      }

      async function loadGameState() {
        try {
          const res = await fetch(`/games/${gameId}/state`, { cache: 'no-store' });
          const text = await res.text();

          if (!res.ok) {
            throw new Error(`HTTP ${res.status}: ${text}`);
          }

          if (!text || !text.trim()) {
            throw new Error('Empty response from server');
          }

          console.log('Raw response:', text);
          const data = JSON.parse(text);
          console.log('Parsed response:', data);

          gameState = data.gameState;
          const newCards = data.playerHand || [];
          
          // Preserve custom card order if it exists
          if (cardOrder.length > 0 && newCards.length === playerCards.length) {
            // Reorder new cards based on saved order
            const cardMap = new Map(newCards.map(card => [card.id, card]));
            playerCards = cardOrder.map(id => cardMap.get(id)).filter(card => card !== undefined);
            
            // Add any new cards that weren't in the previous order
            newCards.forEach(card => {
              if (!cardOrder.includes(card.id)) {
                playerCards.push(card);
              }
            });
          } else {
            // First load or card count changed, use server order
            playerCards = newCards;
          }
          
          // Update card order tracking
          cardOrder = playerCards.map(card => card.id);

          window.lastStateAllCards = [...(data.playerHand || []), ...(data.myLaidCards || [])];
          updateGameDisplay();
        } catch (err) {
          console.error('Error loading game state:', err);
          showError('Failed to load game state: ' + err.message);
        }
      }

      function updateGameDisplay() {
        if (!gameState) return;
        
        document.getElementById('game-state').textContent = gameState.state || 'unknown';
        
        renderOtherPlayers();
        renderPlayerHand();
        renderDeck();
        renderDiscardPile();
        updateTurnIndicator();
        renderLaidSets();
        updateFinishedState();
        checkForWinner();
        updateStartButtonState();
        updateAddToMeldButton();
      }

      function updateStartButtonState() {
        const startBtn = document.getElementById('start-game');
        if (!startBtn) return;
        
        const playerCount = (gameState.players || []).length;
        const maxPlayers = <%- game.max_players %>;
        const isFull = playerCount === maxPlayers;
        
        startBtn.disabled = !isFull;
        if (!isFull) {
          startBtn.title = `Waiting for ${maxPlayers - playerCount} more player(s) (${playerCount}/${maxPlayers})`;
          startBtn.textContent = `Start Game (${playerCount}/${maxPlayers})`;
        } else {
          startBtn.title = 'All players joined - Ready to start!';
          startBtn.textContent = 'Start Game';
        }
      }

      function checkForWinner() {
        // Detect winner via gameState.winner_id (backend now provides it)
        const winnerId = gameState.winner_id || null;
        if (winnerId && !hasWinner) {
          hasWinner = true;
          const btn = document.getElementById('declare-btn');
          if (btn) {
            btn.style.display = 'inline-block';
          }
          // Auto-end the game 2 seconds after winner is detected
          setTimeout(() => {
            declareWinner();
          }, 2000);
        }
      }

      function renderLaidSets() {
        const container = document.getElementById('laid-sets');
        if (!container) return;
        container.innerHTML = '';
        const me = gameState.players?.find(p => p.player_id === currentUserId);
        const melds = Array.isArray(me?.melds) ? me.melds : (me?.melds ? JSON.parse(me.melds) : []);
        const laidMap = new Map((window.lastStateAllCards || []).map(c => [c.id, c]));

        // Populate select options
        const select = document.getElementById('meld-select');
        if (select) {
          select.innerHTML = '';
          melds.forEach((m, idx) => {
            const opt = document.createElement('option');
            opt.value = String(idx);
            opt.textContent = `Set ${idx + 1} (${m.length} cards)`;
            select.appendChild(opt);
          });
          // Ensure button state is updated
          updateAddToMeldButton();
        }

        for (const meld of melds) {
          const group = document.createElement('div');
          group.className = 'd-flex align-items-center gap-1 p-2 border rounded bg-white';
          group.dataset.meldIndex = String(container.children.length);
          group.addEventListener('dragover', handleHandDragOver);
          group.addEventListener('drop', handleMeldDrop);
          for (const cardId of meld) {
            const c = laidMap.get(cardId);
            if (!c) continue;
            const div = document.createElement('div');
            div.className = `playing-card ${getSuitColor(c.suit)}`;
            div.draggable = true;
            div.dataset.cardId = String(c.id);
            div.dataset.meldIndex = String(container.children.length);
            div.addEventListener('dragstart', handleMeldCardDragStart);
            div.addEventListener('dragend', handleMeldCardDragEnd);
            div.innerHTML = `<div class="card-rank">${c.rank}</div><div class="card-suit">${getSuitSymbol(c.suit)}</div>`;
            group.appendChild(div);
          }
          container.appendChild(group);
        }
      }

      function renderOtherPlayers() {
        const container = document.getElementById('other-players');
        container.innerHTML = '';
        
        if (!gameState.players || !Array.isArray(gameState.players)) {
          console.warn('No players data:', gameState.players);
          return;
        }
        
        gameState.players.forEach(player => {
          const div = document.createElement('div');
          div.className = 'player-info';
          if (player.player_id === gameState.current_turn_player_id) {
            div.classList.add('active');
          }
          
          const isCurrentUser = player.player_id === currentUserId;
          const userLabel = isCurrentUser ? ' (You)' : '';
          
          div.innerHTML = `
            <div class="fw-bold text-dark">${player.username}${userLabel}</div>
            <div class="small text-muted">${player.card_count || 0} cards</div>
          `;
          container.appendChild(div);
        });
        
        console.log('Rendered players:', gameState.players, 'currentUserId:', currentUserId);
      }

      function renderPlayerHand() {
        const container = document.getElementById('player-hand');
        container.innerHTML = '';

        // Allow dropping cards dragged from laid sets back into hand
        if (!container.dataset.dropInit) {
          container.addEventListener('dragover', handleHandDragOver);
          container.addEventListener('drop', handleHandDrop);
          container.dataset.dropInit = '1';
        }
        
        if (!playerCards || playerCards.length === 0) {
          container.innerHTML = '<div class="text-muted">No cards yet</div>';
          return;
        }
        
        playerCards.forEach((card, index) => {
          const cardDiv = createCardElement(card, index);
          // Re-apply selected class if this card was previously selected
          if (selectedCardsForSet.includes(card.id)) {
            cardDiv.classList.add('selected');
          }
          container.appendChild(cardDiv);
        });
      }

      function createCardElement(card, index) {
        const div = document.createElement('div');
        div.className = `playing-card ${getSuitColor(card.suit)}`;
        div.id = `card-${card.id}`;
        div.draggable = true;
        div.dataset.cardIndex = index;
        div.dataset.cardId = card.id;
        
        let isDragging = false;
        
        // Drag events
        div.addEventListener('dragstart', function(e) {
          isDragging = true;
          handleDragStart.call(this, e);
        });
        div.addEventListener('dragover', handleDragOver);
        div.addEventListener('drop', handleDrop);
        div.addEventListener('dragend', function(e) {
          handleDragEnd.call(this, e);
          setTimeout(() => { isDragging = false; }, 100);
        });
        
        // Click event for selection (only if not dragging)
        div.addEventListener('click', function(e) {
          if (!isDragging) {
            selectCard(card.id, this, e);
          }
        });
        
        const suitSymbol = getSuitSymbol(card.suit);
        div.innerHTML = `
          <div>
            <div class="card-rank">${card.rank}</div>
            <div class="card-suit">${suitSymbol}</div>
          </div>
        `;
        return div;
      }

      let draggedCard = null;
      let hasWinner = false;

      function handleDragStart(e) {
        draggedCard = this;
        dragPayload = { source: 'hand', cardId: Number(this.dataset.cardId || 0) };
        this.style.opacity = '0.5';
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', this.innerHTML);
      }

      function handleDragOver(e) {
        if (e.preventDefault) {
          e.preventDefault();
        }
        e.dataTransfer.dropEffect = 'move';
        return false;
      }

      function handleDrop(e) {
        if (e.stopPropagation) {
          e.stopPropagation();
        }
        if (e.preventDefault) {
          e.preventDefault();
        }

        // If dragging from a meld, let the hand container handle it
        if (dragPayload && dragPayload.source === 'meld') {
          return false;
        }

        if (draggedCard && draggedCard !== this) {
          const fromIndex = parseInt(draggedCard.dataset.cardIndex);
          const toIndex = parseInt(this.dataset.cardIndex);
          
          // Rearrange cards array
          const [movedCard] = playerCards.splice(fromIndex, 1);
          playerCards.splice(toIndex, 0, movedCard);
          
          // Update card order tracking
          cardOrder = playerCards.map(card => card.id);
          
          // Persist card order to database
          const cardIds = playerCards.map(card => card.id);
          fetch(`/games/<%= game.id %>/arrange-hand`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ cardIds })
          }).catch(err => console.error('Failed to save card order:', err));
          
          // Save selected card ID before re-render
          const selectedId = selectedCardId;
          
          // Re-render hand
          renderPlayerHand();
          
          // Restore selection
          if (selectedId) {
            const selectedElement = document.getElementById(`card-${selectedId}`);
            if (selectedElement) {
              selectedElement.classList.add('selected');
            }
          }
        }
        
        return false;
      }

      function handleDragEnd(e) {
        this.style.opacity = '1';
        draggedCard = null;
        dragPayload = null;
      }

      function handleHandDragOver(e) {
        if (e.preventDefault) e.preventDefault();
      }

      function handleHandDrop(e) {
        if (e.preventDefault) e.preventDefault();
        if (dragPayload && dragPayload.source === 'meld') {
          moveCardBetweenGroups({
            cardId: dragPayload.cardId,
            from: 'meld',
            to: 'hand',
            fromMeldIndex: dragPayload.meldIndex
          });
        }
      }

      function handleMeldCardDragStart(e) {
        dragPayload = {
          source: 'meld',
          cardId: Number(this.dataset.cardId || 0),
          meldIndex: Number(this.dataset.meldIndex || -1)
        };
        this.style.opacity = '0.5';
        e.dataTransfer.effectAllowed = 'move';
      }

      function handleMeldCardDragEnd() {
        this.style.opacity = '1';
        dragPayload = null;
      }

      function handleMeldDrop(e) {
        if (e.preventDefault) e.preventDefault();
        const idx = Number(this.dataset.meldIndex || -1);
        if (dragPayload && dragPayload.source === 'hand') {
          moveCardBetweenGroups({
            cardId: dragPayload.cardId,
            from: 'hand',
            to: 'meld',
            toMeldIndex: idx
          });
        }
      }

      function getSuitColor(suit) {
        return (suit === 'hearts' || suit === 'diamonds') ? 'red' : 'black';
      }

      function getSuitSymbol(suit) {
        const symbols = {
          hearts: '‚ô•',
          diamonds: '‚ô¶',
          clubs: '‚ô£',
          spades: '‚ô†'
        };
        return symbols[suit] || '?';
      }

      function selectCard(cardId, element, evt) {
        // Shift key allows multiple selection for sets
        if (evt && evt.shiftKey) {
          if (selectedCardsForSet.includes(cardId)) {
            selectedCardsForSet = selectedCardsForSet.filter(id => id !== cardId);
            element.classList.remove('selected');
          } else {
            selectedCardsForSet.push(cardId);
            element.classList.add('selected');
          }
          updateSetButton();
        } else {
          // Single selection for discard
          if (selectedCardId === cardId) {
            selectedCardId = null;
            element.classList.remove('selected');
          } else {
            document.querySelectorAll('.playing-card.selected').forEach(el => {
              if (!selectedCardsForSet.includes(parseInt(el.id.replace('card-', '')))) {
                el.classList.remove('selected');
              }
            });
            selectedCardId = cardId;
            element.classList.add('selected');
          }
          document.getElementById('discard-btn').disabled = selectedCardId === null;
          // Toggle add-to-meld button availability
          updateAddToMeldButton();
        }
      }

      function updateSetButton() {
        const btn = document.getElementById('lay-down-set-btn');
        if (selectedCardsForSet.length >= 3) {
          btn.disabled = false;
          btn.textContent = `Lay Down Cards (${selectedCardsForSet.length} cards)`;
        } else {
          btn.disabled = true;
          btn.textContent = 'Lay Down Cards';
        }
      }

      function renderDeck() {
        const count = gameState.deck_count || 0;
        document.getElementById('deck-count').textContent = count;
      }

      function renderDiscardPile() {
        const container = document.getElementById('discard-top-card');
        if (!gameState.discard_pile || gameState.discard_pile.length === 0) {
          container.innerHTML = `
            <div class="text-muted">Discard Pile</div>
            <div class="small text-muted">Empty</div>
          `;
        } else {
          const topCard = gameState.discard_pile[0];
          container.innerHTML = createCardElement(topCard).outerHTML;
        }
      }

      function updateTurnIndicator() {
        const indicator = document.getElementById('turn-indicator');
        if (gameState.state !== 'in_progress') {
          indicator.textContent = '';
          // When not in progress, disable all actions
          const deckBtn = document.getElementById('draw-deck-btn');
          const discardDrawBtn = document.getElementById('draw-discard-btn');
          const discardBtn = document.getElementById('discard-btn');
          const layBtn = document.getElementById('lay-down-set-btn');
          if (deckBtn) deckBtn.style.pointerEvents = 'none';
          if (discardDrawBtn) discardDrawBtn.style.pointerEvents = 'none';
          if (discardBtn) discardBtn.disabled = true;
          if (layBtn) layBtn.disabled = true;
          return;
        }
        
        const isMyTurn = gameState.current_turn_player_id === currentUserId;
        if (isMyTurn) {
          indicator.textContent = "‚úì It's your turn!";
          indicator.className = 'small text-success ms-3';
        } else {
          const currentPlayer = gameState.players?.find(p => p.player_id === gameState.current_turn_player_id);
          const playerName = currentPlayer?.username || 'Someone';
          indicator.textContent = `Waiting for ${playerName}...`;
          indicator.className = 'small text-muted ms-3';
        }

        // Enable/disable actions per turn rules
        const deckBtn = document.getElementById('draw-deck-btn');
        const discardDrawBtn = document.getElementById('draw-discard-btn');
        const discardBtn = document.getElementById('discard-btn');
        const layBtn = document.getElementById('lay-down-set-btn');
        if (deckBtn) deckBtn.style.pointerEvents = isMyTurn ? 'auto' : 'none';
        if (discardDrawBtn) discardDrawBtn.style.pointerEvents = isMyTurn ? 'auto' : 'none';
        if (discardBtn) {
          discardBtn.disabled = !isMyTurn;
          // Add visual styling for disabled state
          if (!isMyTurn) {
            discardBtn.style.opacity = '0.5';
            discardBtn.style.cursor = 'not-allowed';
          } else {
            discardBtn.style.opacity = '1';
            discardBtn.style.cursor = 'pointer';
          }
        }
        // Lay Down Set stays enabled even when not your turn
        if (layBtn) layBtn.disabled = false;
      }

      async function startGame() {
        console.log('Start game clicked, gameId:', gameId);
        try {
          const res = await fetch(`/games/${gameId}/start`, { 
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            credentials: 'same-origin'
          });
          console.log('Response status:', res.status);
          
          // Check if response is JSON
          const contentType = res.headers.get('content-type');
          console.log('Content-Type:', contentType);
          
          if (!contentType || !contentType.includes('application/json')) {
            const text = await res.text();
            console.error('Non-JSON response:', text.substring(0, 200));
            throw new Error('Server returned HTML instead of JSON');
          }
          
          const data = await res.json();
          console.log('Response data:', data);
          
          if (res.ok) {
            showError('Game started successfully!');
            await loadGameState();
          } else {
            showError(data.error || 'Failed to start game');
          }
        } catch (err) {
          console.error('Start game error:', err);
          showError('Error: ' + err.message);
        }
      }

      async function drawFromDeck() {
        try {
          const res = await fetch(`/games/${gameId}/draw-deck`, { method: 'POST' });
          const data = await res.json();
          
          if (res.ok) {
            await loadGameState();
          } else {
            showError(data.error || 'Failed to draw from deck');
          }
        } catch (err) {
          showError('Error: ' + err.message);
        }
      }

      async function drawFromDiscard() {
        try {
          const res = await fetch(`/games/${gameId}/draw-discard`, { method: 'POST' });
          const data = await res.json();
          
          if (res.ok) {
            await loadGameState();
          } else {
            showError(data.error || 'Failed to draw from discard');
          }
        } catch (err) {
          showError('Error: ' + err.message);
        }
      }

      async function discardCard() {
        if (!selectedCardId) {
          showError('Please select a card to discard');
          return;
        }
        
        try {
          const res = await fetch(`/games/${gameId}/discard`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ cardId: selectedCardId })
          });
          const data = await res.json();
          
          if (res.ok) {
            selectedCardId = null;
            if (data.won) {
              showMeldMessage('üéâ You won! All cards melded!', 'success');
              showFinishedBanner('You won! Game over.');
              disableAllActions();
            } else {
              await loadGameState();
            }
          } else {
            showError(data.error || 'Failed to discard card');
          }
        } catch (err) {
          showError('Error: ' + err.message);
        }
      }

      async function declareWinner() {
        try {
          const res = await fetch(`/games/${gameId}/declare`, { method: 'POST' });
          const data = await res.json();
          
          if (res.ok) {
            showFinishedBanner('Game finished.');
            disableAllActions();
          } else {
            showError(data.error || 'Failed to declare winner');
          }
        } catch (err) {
          showError('Error: ' + err.message);
        }
      }

      function confirmEndGame() {
        const ok = window.confirm('End this game for all players? This cannot be undone.');
        if (!ok) return;
        const btn = document.getElementById('declare-btn');
        if (btn) btn.disabled = true;
        declareWinner();
      }

      async function layDownSet() {
        if (selectedCardsForSet.length < 3) {
          showMeldMessage('Please select at least 3 cards to form a set', 'error');
          return;
        }

        // Get the selected cards
        const setCards = playerCards.filter(card => selectedCardsForSet.includes(card.id));
        
        // Validate it's a valid sequence (consecutive ranks, same suit) OR set (same rank, distinct suits)
        if (!validateSet(setCards)) {
          showMeldMessage('Invalid meld. Must be either a sequence (3+ consecutive same suit) or a set (3-4 same rank, distinct suits).', 'error');
          return;
        }

        try {
          const res = await fetch(`/games/${gameId}/lay-set`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ cardIds: selectedCardsForSet })
          });
          
          const data = await res.json();
          
          if (res.ok) {
            if (data.won) {
              showMeldMessage('üéâ You won! All cards melded!', 'success');
              selectedCardsForSet = [];
              updateSetButton();
              showFinishedBanner('You won! Game over.');
              disableAllActions();
            } else {
              showMeldMessage('Sequence laid down successfully!', 'success');
              selectedCardsForSet = [];
              updateSetButton();
              await loadGameState();
            }
          } else {
            showMeldMessage(data.error || 'Failed to lay down sequence', 'error');
          }
        } catch (err) {
          showMeldMessage('Error: ' + err.message, 'error');
        }
      }

      async function addCardToMeld() {
        const select = document.getElementById('meld-select');
        const msgEl = document.getElementById('add-to-meld-msg');
        if (!select) return;
        const meldIndex = parseInt(select.value);
        if (Number.isNaN(meldIndex)) {
          msgEl.textContent = 'Please select a set to add to';
          msgEl.className = 'small text-danger ms-2';
          return;
        }
        if (selectedCardId === null) {
          msgEl.textContent = 'Select a card in your hand first';
          msgEl.className = 'small text-danger ms-2';
          return;
        }

        try {
          const res = await fetch(`/games/${gameId}/add-to-meld`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ meldIndex, cardId: selectedCardId })
          });
          
          // Check if response is JSON
          const contentType = res.headers.get('content-type');
          if (!contentType || !contentType.includes('application/json')) {
            const text = await res.text();
            console.error('Non-JSON response:', text.substring(0, 500));
            msgEl.textContent = 'Server error - check console';
            msgEl.className = 'small text-danger ms-2';
            return;
          }
          
          const data = await res.json();
          if (res.ok) {
            msgEl.textContent = 'Card added to set!';
            msgEl.className = 'small text-success ms-2';
            // Clear selection and refresh state
            selectedCardId = null;
            document.querySelectorAll('.playing-card.selected').forEach(el => el.classList.remove('selected'));
            await loadGameState();
          } else {
            msgEl.textContent = data.error || 'Could not add card to set';
            msgEl.className = 'small text-danger ms-2';
          }
        } catch (err) {
          msgEl.textContent = 'Error: ' + err.message;
          msgEl.className = 'small text-danger ms-2';
        }
        setTimeout(() => { if (msgEl) msgEl.textContent = ''; }, 4000);
      }

      function validateSet(cards) {
        if (cards.length < 3) return false;

        const hiddenJoker = gameState?.hidden_joker_rank || null;
        const rankOrder = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

        console.log('validateSet: hiddenJoker rank:', hiddenJoker);
        console.log('validateSet: total cards', cards.length);
        console.log('validateSet: cards', cards.map(c => `${c.rank}${c.suit}`));

        // Separate wildcards (hidden joker rank acts as wildcard regardless of suit)
        const isWild = (card) => hiddenJoker && card.rank === hiddenJoker;
        const nonWild = cards.filter(c => !isWild(c));
        const wildCount = cards.length - nonWild.length;

        console.log('validateSet: wildcards', wildCount, 'non-wild', nonWild.length);
        console.log('validateSet: non-wild cards', nonWild.map(c => `${c.rank}${c.suit}`));

        // Try validating as a SET first (3-4 same rank, distinct suits)
        // Can be: 3-4 cards total, with all non-wild cards having same rank and distinct suits
        if (cards.length >= 3 && cards.length <= 4) {
          const ranks = new Set(nonWild.map(c => c.rank));
          const suits = new Set(nonWild.map(c => c.suit));
          
          console.log('validateSet: SET check - ranks.size:', ranks.size, 'suits.size:', suits.size, 'nonWild.length:', nonWild.length);
          
          // If all non-wild cards have the same rank and distinct suits, it's a valid set
          // Wildcards can fill in missing suits
          if (ranks.size === 1 && suits.size === nonWild.length) {
            console.log('validateSet: Valid SET (same rank, distinct suits with wildcards)');
            return true;
          }
        }

        // Try validating as a SEQUENCE (consecutive ranks, same suit)
        // All non-wild cards must share suit (wildcards are suit-agnostic)
        const suits = new Set(nonWild.map(c => c.suit));
        if (suits.size > 1) {
          console.log('validateSet failed: multiple suits in non-wildcards (not a sequence or set)', Array.from(suits));
          return false;
        }
        
        // If we have non-wild cards, get their suit
        const suit = suits.size > 0 ? Array.from(suits)[0] : null;

        // Require at least one non-wild card
        if (nonWild.length === 0) {
          console.log('validateSet failed: all wildcards');
          return false;
        }

        // Convert ranks to indices and ensure no duplicate ranks among non-wilds
        const indices = nonWild.map(c => rankOrder.indexOf(c.rank)).filter(i => i >= 0).sort((a, b) => a - b);
        for (let i = 1; i < indices.length; i++) {
          if (indices[i] === indices[i - 1]) {
            console.log('validateSet failed: duplicate rank', rankOrder[indices[i]]);
            return false; // duplicate rank breaks a run
          }
        }

        // Count gaps between non-wild ranks
        let gaps = 0;
        for (let i = 1; i < indices.length; i++) {
          const diff = indices[i] - indices[i - 1];
          if (diff < 1) {
            console.log('validateSet failed: negative diff');
            return false;
          }
          if (diff > 1) gaps += (diff - 1);
        }

        // Wildcards can fill gaps
        if (gaps > wildCount) {
          console.log('validateSet failed: too many gaps', gaps, 'wildcards', wildCount);
          return false;
        }

        // After filling gaps, remaining wilds can extend ends, so this is valid
        console.log('validateSet passed: valid sequence');
        return true;
      }

      function showMeldMessage(msg, type) {
        const msgEl = document.getElementById('meld-message');
        msgEl.textContent = msg;
        msgEl.className = `mt-2 small ${type === 'error' ? 'text-danger' : 'text-success'}`;
        setTimeout(() => { msgEl.textContent = ''; }, 5000);
      }

      function showError(msg) {
        const alert = document.getElementById('error-alert');
        alert.textContent = msg;
        alert.style.display = 'block';
        setTimeout(() => { alert.style.display = 'none'; }, 5000);
      }

      let finishedRedirectTimer = null;
      function showFinishedBanner(text) {
        const banner = document.getElementById('finished-banner');
        const label = document.getElementById('finished-text');
        label.textContent = text || 'Game over!';
        banner.style.display = 'block';
        // Keep banner, but rely on modal CTA for navigation
      }

      document.getElementById('finished-back-btn')?.addEventListener('click', () => {
        window.location.href = `/games/${gameId}/results`;
      });

      function showResultsModal({ winnerName = 'Player', hiddenJokerRank = null, scores = [] }) {
        // If bootstrap JS failed to load, skip modal to avoid throwing
        if (!window.bootstrap || !window.bootstrap.Modal) {
          showError('Bootstrap JS is missing; results modal skipped.');
          return;
        }

        if (!resultsModal) {
          const modalEl = document.getElementById('results-modal');
          resultsModal = new bootstrap.Modal(modalEl, { backdrop: 'static', keyboard: false });
          document.getElementById('results-play-again').addEventListener('click', () => window.location.reload());
          document.getElementById('results-to-lobby').addEventListener('click', () => window.location.href = '/lobby');
        }

        const winnerEl = document.getElementById('results-winner-text');
        winnerEl.textContent = `${winnerName} Wins!`;

        const jokerEl = document.getElementById('results-joker-text');
        const jokerRankEl = document.getElementById('results-joker-rank');
        if (hiddenJokerRank) {
          jokerEl.style.display = 'inline-block';
          jokerRankEl.textContent = hiddenJokerRank;
        } else {
          jokerEl.style.display = 'none';
        }

        const scoresEl = document.getElementById('results-scores');
        scoresEl.innerHTML = '';
        scores.forEach((s, idx) => {
          const div = document.createElement('div');
          div.className = 'results-list';
          const place = idx + 1;
          const suffix = place === 1 ? 'st' : place === 2 ? 'nd' : place === 3 ? 'rd' : 'th';
          const winnerTag = idx === 0 ? ' (Winner!)' : '';
          div.textContent = `${place}${suffix} - ${s.name}: ${s.points} points${winnerTag}`;
          scoresEl.appendChild(div);
        });

        resultsModal.show();

        // Auto-redirect everyone to the standalone results page after 6s if they don't click
        setTimeout(() => {
          window.location.href = `/games/${gameId}/results`;
        }, 6000);
      }

      function disableAllActions() {
        document.getElementById('draw-deck-btn').style.pointerEvents = 'none';
        document.getElementById('draw-discard-btn').style.pointerEvents = 'none';
        const discardBtn = document.getElementById('discard-btn');
        const layBtn = document.getElementById('lay-down-set-btn');
        discardBtn.disabled = true;
        layBtn.disabled = true;
      }

      function updateFinishedState() {
        if (gameState.state === 'finished') {
          const winnerId = gameState.winner_id || null;
          const winner = winnerId ? (gameState.players || []).find(p => p.player_id === winnerId) : null;
          const name = winner?.username ? `${winner.username} Wins!` : 'Game over!';
          showFinishedBanner(name);
          disableAllActions();

          // Build scores array (sorted by card_count as placeholder since scoring not provided)
          const scores = (gameState.players || []).map(p => ({ name: p.username, points: Number(p.card_count) || 0 }))
            .sort((a, b) => a.points - b.points);

          const hiddenJokerRank = gameState.hidden_joker_rank || null;
          showResultsModal({ winnerName: winner?.username || 'Player', hiddenJokerRank, scores });
          // If no bootstrap modal (guarded above), still redirect after delay to lobby
          if (!window.bootstrap || !window.bootstrap.Modal) {
            setTimeout(() => { window.location.href = `/games/${gameId}/results`; }, 6000);
          }
        }
      }

      // Set up event listeners AFTER functions are defined
      const startBtn = document.getElementById('start-game');
      console.log('Start button element:', startBtn);
      startBtn?.addEventListener('click', () => {
        console.log('Start button clicked!');
        startGame();
      });
      document.getElementById('draw-deck-btn').addEventListener('click', drawFromDeck);
      document.getElementById('draw-discard-btn').addEventListener('click', drawFromDiscard);
      document.getElementById('discard-btn').addEventListener('click', discardCard);
      document.getElementById('lay-down-set-btn').addEventListener('click', layDownSet);
      document.getElementById('declare-btn')?.addEventListener('click', confirmEndGame);
      document.getElementById('add-to-meld-btn')?.addEventListener('click', addCardToMeld);
      document.getElementById('meld-select')?.addEventListener('change', updateAddToMeldButton);

      // Load initial state and set up polling
      loadGameState();
      setInterval(loadGameState, 2000);
      
      // Listen for game:winner socket event (real-time win detection)
      if (typeof io !== 'undefined') {
        const socket = io();
        socket.on('game:winner', (data) => {
          console.log('game:winner event received:', data);
          // Reload state to get updated winner_id and state
          loadGameState().then(() => {
            // updateFinishedState() will be called by updateGameDisplay
          });
        });

        // Reveal hidden joker rank in header when pure sequence laid
        socket.on('game:joker-revealed', (data) => {
          console.log('game:joker-revealed:', data);
          // Only update if this event is for the current user
          if (data.userId && data.userId !== currentUserId) {
            console.log('Joker revealed for different user, ignoring');
            return;
          }
          const rank = data?.hiddenJokerRank;
          if (rank) {
            console.log('Revealing joker rank:', rank);
            // Update the header to show the joker rank
            const jokerHidden = document.getElementById('joker-hidden');
            if (jokerHidden) {
              jokerHidden.innerHTML = '<strong class="text-warning">' + rank + '</strong>';
            }
            // Also update gameState for validation
            if (gameState) {
              gameState.hidden_joker_rank = rank;
              const currentPlayer = gameState.players?.find(p => p.player_id === currentUserId);
              if (currentPlayer) {
                currentPlayer.joker_revealed = true;
              }
            }
          }
        });

        socket.on('game:card-added-to-meld', (data) => {
          console.log('game:card-added-to-meld:', data);
          // Light refresh to reflect updated melds
          loadGameState();
        });
      }
      
      // Initialize button states
      updateSetButton();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  </body>
</html>
